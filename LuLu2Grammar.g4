grammar LuLu2Grammar;
program:ft_dcl? ft_def+;
ft_dcl: KEYWORD_DECLARE OPENING_BRACE ( func_dcl | type_dcl | var_def )+ CLOSING_BRACE;
func_dcl: ( '(' args ')' '=' )? ID '(' ( args | args_var )? ')' ';';
args : type ( '[' ']' )* | args ',' type ( '[' ']' )*;
args_var : type ( '[' ']' )* ID | args_var ',' type ( '[' ']' )* ID;
type_dcl : ID ';';
var_def : KEYWORD_CONST? type var_val ( ',' var_val )* ';';
var_val : ref ( '=' expr)? ;
ft_def : ( type_def | fun_def ) ;
type_def : KEYWORD_TYPE ID ( ':' ID )? OPENING_BRACE component+ CLOSING_BRACE ;
component : access_modifier ? ( var_def | fun_def );
access_modifier : KEYWORD_PRIVATE | KEYWORD_PUBLIC | KEYWORD_PROTECTED;
fun_def : ( '(' args_var ')' '=' )? KEYWORD_FUNCTION ID '(' args_var? ')' block;
block: OPENING_BRACE ( var_def | stmt )* '}';
stmt : assign ';' | func_call ';' | cond_stmt | loop_stmt | KEYWORD_RETURN ';' |KEYWORD_BREAK ';' | KEYWORD_CONTINUE ';' | KEYWORD_DESTRUCT ( '[' ']' )* ID ';' ;
assign : ( var | '(' var ( ',' var )*')' ) '=' expr;
var : ( ( KEYWORD_THIS | KEYWORD_SUPER ) '.' )? ref ( '.' ref )*;
ref : ID ( '[' expr ']' )*;
expr : expr BINARY_OP expr | '(' expr ')' | UNARY_OP expr| const_val | KEYWORD_ALLOCATE handle_call | func_call | var | list | KEYWORD_NIL;
func_call : ( var '.' )? handle_call | KEYWORD_READ '(' var ')' | KEYWORD_WRITE '(' var ')';
list : '[' ( expr | list ) ( ',' ( expr| list ) )*']';
handle_call : ID '(' params? ')';
params : expr | expr ',' params;
cond_stmt : KEYWORD_IF expr block ( KEYWORD_ELSE block )? | KEYWORD_SWITCH var OPENING_BRACE ( KEYWORD_CASE INT_CONST ':' block )* KEYWORD_DEFAULT ':' block CLOSING_BRACE;
loop_stmt : KEYWORD_FOR ( type? assign )? ';' expr ';' assign? block | KEYWORD_WHILE expr block;
type : KEYWORD_INT | KEYWORD_BOOL | KEYWORD_FLOAT | KEYWORD_STRING | ID;
const_val : INT_CONST | REAL_CONST | BOOL_CONST | STRING_CONST;
KEYWORD_DECLARE:'declare';
KEYWORD_RETURN: 'return';
KEYWORD_BREAK:'break';
KEYWORD_CONTINUE:'continue';
KEYWORD_DESTRUCT:'destruct';
KEYWORD_THIS:'this';
KEYWORD_SUPER:'super';
KEYWORD_CONST:'const';
KEYWORD_PRIVATE:'private';
KEYWORD_PUBLIC:'public';
KEYWORD_PROTECTED:'protected';
KEYWORD_INT:'int';
KEYWORD_BOOL:'bool';
KEYWORD_FLOAT:'float';
KEYWORD_STRING:'string';
KEYWORD_FUNCTION:'function';
KEYWORD_CASE:'case';
KEYWORD_DEFAULT:'default';
KEYWORD_READ:'read';
KEYWORD_WRITE:'write';
KEYWORD_WHILE:'while';
KEYWORD_ALLOCATE:'allocate';
KEYWORD_TYPE:'type';
KEYWORD_NIL:'nil';
KEYWORD_IF:'if';
KEYWORD_ELSE:'else';
KEYWORD_SWITCH:'switch';
KEYWORD_FOR:'for';
KEYWORD_FALSE:'false';
KEYWORD_TRUE:'true';
OPENING_BRACE:'{';
CLOSING_BRACE:'}';
ID: ([a-zA-Z#_])([a-zA-Z0-9#_])*;
INT_CONST: ([0][Xx][0-9A-Fa-f]+)|([0-9]+);
EXPONENT: ([eE])([+-])?([0-9]+);
REAL_CONST: (INT_CONST?[.][0-9]*)EXPONENT?;
STRING_CONST: [‘](~'\\'|ESCAPE_CHARACTER)*?[’];
BINARY_OP : ARITHMETIC_OPERATORS | RELATIONAL_OPERATORS | BIT_OPERATORS | LOGICAL_OPERATORS;
ESCAPE_CHARACTER: '\\n'|'\\r'|'\\\\'|'\\t'|'\\0'|'\\’'|('\\'[xX][0-9a-fA-F][0-9a-fA-F]);
BOOL_CONST: KEYWORD_TRUE|KEYWORD_FALSE;
RELATIONAL_OPERATORS: '=='|'!='|'<='|'<'|'>'|'>=';
LOGICAL_OPERATORS : '||' | '&&';
UNARY_OP : [-!~];
BIT_OPERATORS: [|&^];
ARITHMETIC_OPERATORS: [-+*/%];
COMMENT:(('%%'(~[\n])*)|('%~'.*?'~%')) -> skip;
WHITESPACE:([ \t\n\r])+ -> skip;

